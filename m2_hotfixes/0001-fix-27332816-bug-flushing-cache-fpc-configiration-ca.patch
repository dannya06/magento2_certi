From c458db79569413014d42b7e65fbfc5ed0ec9a553 Mon Sep 17 00:00:00 2001
From: icube-yuwan <yuma.anugrah@mail.sirclo.com>
Date: Tue, 2 Aug 2022 15:28:39 +0000
Subject: [PATCH] fix([27332816] [bug] flushing cache (fpc / configiration
 cache) causes blank page pwa): update patch

---
 .../GraphQlSchemaStitching/GraphQlReader.php  | 216 ++++++++++++------
 1 file changed, 145 insertions(+), 71 deletions(-)

diff --git a/vendor/magento/framework/GraphQlSchemaStitching/GraphQlReader.php b/vendor/magento/framework/GraphQlSchemaStitching/GraphQlReader.php
index 9845646e0..845bf7c64 100644
--- a/vendor/magento/framework/GraphQlSchemaStitching/GraphQlReader.php
+++ b/vendor/magento/framework/GraphQlSchemaStitching/GraphQlReader.php
@@ -7,7 +7,8 @@ declare(strict_types=1);
 
 namespace Magento\Framework\GraphQlSchemaStitching;
 
-use Magento\Framework\Component\ComponentRegistrar;
+use GraphQL\Type\Definition\ScalarType;
+use GraphQL\Utils\BuildSchema;
 use Magento\Framework\Config\FileResolverInterface;
 use Magento\Framework\Config\ReaderInterface;
 use Magento\Framework\GraphQlSchemaStitching\GraphQlReader\TypeMetaReaderInterface as TypeReaderComposite;
@@ -47,11 +48,6 @@ class GraphQlReader implements ReaderInterface
      */
     private $defaultScope;
 
-    /**
-     * @var ComponentRegistrar
-     */
-    private static $componentRegistrar;
-
     /**
      * @param FileResolverInterface $fileResolver
      * @param TypeReaderComposite $typeReader
@@ -71,12 +67,12 @@ class GraphQlReader implements ReaderInterface
     }
 
     /**
-     * @inheritDoc
-     *
+     * @inheritdoc
+     * @SuppressWarnings(PHPMD.CyclomaticComplexity)
      * @param string|null $scope
      * @return array
      */
-    public function read($scope = null) : array
+    public function read($scope = null): array
     {
         $results = [];
         $scope = $scope ?: $this->defaultScope;
@@ -86,42 +82,117 @@ class GraphQlReader implements ReaderInterface
         }
 
         /**
+         * Gather as many schema together to be parsed in one go for performance
+         * Collect any duplicate types in an array to retry after the initial large parse
+         *
          * Compatible with @see GraphQlReader::parseTypes
          */
+        $typesToRedo = [];
         $knownTypes = [];
-        foreach ($schemaFiles as $filePath => $partialSchemaContent) {
-            $partialSchemaTypes = $this->parseTypes($partialSchemaContent);
+        foreach ($schemaFiles as $partialSchemaContent) {
+            $partialSchemaTypes = $this->parseTypesWithUnionHandling($partialSchemaContent);
+
+            // Filter out duplicated ones and save them into a list to be retried
+            $tmpTypes = $knownTypes;
+            foreach ($partialSchemaTypes as $intendedKey => $partialSchemaType) {
+                if (isset($tmpTypes[$intendedKey])) {
+                    if (!isset($typesToRedo[$intendedKey])) {
+                        $typesToRedo[$intendedKey] = [];
+                    }
+                    $typesToRedo[$intendedKey][] = $partialSchemaType;
+                    continue;
+                }
+                $tmpTypes[$intendedKey] = $partialSchemaType;
+            }
+            $knownTypes = $tmpTypes;
+        }
+
+        /**
+         * Read this large batch of data, this builds most of the $results array
+         */
+        $schemaContent = implode("\n", $knownTypes);
+        $results = $this->readPartialTypes($schemaContent);
+
+        /**
+         * Go over the list of types to be retried and batch them up into as few batches as possible
+         */
+        $typesToRedoBatches = [];
+        foreach ($typesToRedo as $type => $batches) {
+            foreach ($batches as $id => $data) {
+                if (!isset($typesToRedoBatches[$id])) {
+                    $typesToRedoBatches[$id] = [];
+                }
+                $typesToRedoBatches[$id][$type] = $data;
+            }
+        }
 
-            // Keep declarations from current partial schema, add missing declarations from all previously read schemas
-            $knownTypes = $partialSchemaTypes + $knownTypes;
-            $schemaContent = implode("\n", $knownTypes);
+        /**
+         * Process each remaining batch with the minimal amount of additional schema data for performance
+         */
+        foreach ($typesToRedoBatches as $typesToRedoBatch) {
+            $typesToUse =  $this->getTypesToUse($typesToRedoBatch, $knownTypes);
+            $knownTypes = $typesToUse + $knownTypes;
+            $schemaContent = implode("\n", $typesToUse);
 
             $partialResults = $this->readPartialTypes($schemaContent);
             $results = array_replace_recursive($results, $partialResults);
-            $results = $this->addModuleNameToTypes($results, $filePath);
         }
 
         $results = $this->copyInterfaceFieldsToConcreteTypes($results);
         return $results;
     }
 
+    /**
+     * Get the minimum amount of additional types so that performance is improved
+     *
+     * The use of a strpos check here is a bit odd in the context of feeding data into an AST but for the performance
+     * gains and to prevent downtime it is necessary
+     *
+     * @link https://github.com/webonyx/graphql-php/issues/244
+     * @link https://github.com/webonyx/graphql-php/issues/244#issuecomment-383912418
+     *
+     * @param array $typesToRedoBatch
+     * @param array $types
+     * @return array
+     */
+    private function getTypesToUse($typesToRedoBatch, $types): array
+    {
+        $totalKnownSymbolsCount = count($typesToRedoBatch) + count($types);
+
+        $typesToUse = $typesToRedoBatch;
+        for ($i=0; $i < $totalKnownSymbolsCount; $i++) {
+            $changesMade = false;
+            $schemaContent = implode("\n", $typesToUse);
+            foreach ($types as $type => $schema) {
+                if ((!isset($typesToUse[$type]) && strpos($schemaContent, $type) !== false)) {
+                    $typesToUse[$type] = $schema;
+                    $changesMade = true;
+                }
+            }
+            if (!$changesMade) {
+                break;
+            }
+        }
+        return $typesToUse;
+    }
+
     /**
      * Extract types as string from schema as string
      *
      * @param string $graphQlSchemaContent
      * @return string[] [$typeName => $typeDeclaration, ...]
      */
-    private function readPartialTypes(string $graphQlSchemaContent) : array
+    private function readPartialTypes(string $graphQlSchemaContent): array
     {
         $partialResults = [];
 
         $graphQlSchemaContent = $this->addPlaceHolderInSchema($graphQlSchemaContent);
 
-        $schema = \GraphQL\Utils\BuildSchema::build($graphQlSchemaContent);
+        $schema = BuildSchema::build($graphQlSchemaContent, null, ['assumeValid'=> true, 'assumeValidSDL' => true]);
 
         foreach ($schema->getTypeMap() as $typeName => $typeMeta) {
             // Only process custom types and skip built-in object types
-            if ((strpos($typeName, '__') !== 0 && (!$typeMeta instanceof \GraphQL\Type\Definition\ScalarType))) {
+            if ((strpos($typeName, '__') !== 0 && (!$typeMeta instanceof ScalarType))) {
                 $type = $this->typeReader->read($typeMeta);
                 if (!empty($type)) {
                     $partialResults[$typeName] = $type;
@@ -131,9 +202,57 @@ class GraphQlReader implements ReaderInterface
             }
         }
 
-        $partialResults = $this->removePlaceholderFromResults($partialResults);
+        return $this->removePlaceholderFromResults($partialResults);
+    }
 
-        return $partialResults;
+    /**
+     * Extract types as string from a larger string that represents the graphql schema using regular expressions
+     *
+     * The regex in parseTypes does not have the ability to split out the union data from the type below it for example
+     *
+     *  > union X = Y | Z
+     *  >
+     *  > type foo {}
+     *
+     * This would produce only type key from parseTypes, X, which would contain also the type foo entry.
+     *
+     * This wrapper does some post processing as a workaround to split out the union data from the type data below it
+     * which would give us two entries, X and foo
+     *
+     * @param string $graphQlSchemaContent
+     * @return string[] [$typeName => $typeDeclaration, ...]
+     */
+    private function parseTypesWithUnionHandling(string $graphQlSchemaContent): array
+    {
+        $types = $this->parseTypes($graphQlSchemaContent);
+
+        /*
+         * A union schema contains also the data from the schema below it
+         *
+         * If there are two newlines in this union schema then it has data below its definition, meaning it contains
+         * type information not relevant to its actual type
+         */
+        $unionTypes = array_filter(
+            $types,
+            function ($t) {
+                return (strpos($t, 'union ') !== false) && (strpos($t, PHP_EOL . PHP_EOL) !== false);
+            }
+        );
+
+        foreach ($unionTypes as $type => $schema) {
+            $splitSchema = explode(PHP_EOL . PHP_EOL, $schema);
+            // Get the type data at the bottom, this will be the additional type data not related to the union
+            $additionalTypeSchema = end($splitSchema);
+            // Parse the additional type from the bottom so we can have its type key => schema pair
+            $additionalTypeData = $this->parseTypes($additionalTypeSchema);
+            // Fix the union type schema so it does not contain the definition below it
+            $types[$type] = str_replace($additionalTypeSchema, '', $schema);
+            // Append the additional data to types array
+            $additionalTypeKey = array_key_first($additionalTypeData);
+            $types[$additionalTypeKey] = $additionalTypeData[$additionalTypeKey];
+        }
+
+        return $types;
     }
 
     /**
@@ -142,11 +261,11 @@ class GraphQlReader implements ReaderInterface
      * @param string $graphQlSchemaContent
      * @return string[] [$typeName => $typeDeclaration, ...]
      */
-    private function parseTypes(string $graphQlSchemaContent) : array
+    private function parseTypes(string $graphQlSchemaContent): array
     {
         $typeKindsPattern = '(type|interface|union|enum|input)';
         $typeNamePattern = '([_A-Za-z][_0-9A-Za-z]+)';
-        $typeDefinitionPattern = '([^\{]*)(\{[^\}]*\})';
+        $typeDefinitionPattern = '([^\{\}]*)(\{[^\}]*\})';
         $spacePattern = '[\s\t\n\r]+';
 
         preg_match_all(
@@ -252,13 +371,13 @@ class GraphQlReader implements ReaderInterface
      * @param string $graphQlSchemaContent
      * @return string
      */
-    private function addPlaceHolderInSchema(string $graphQlSchemaContent) :string
+    private function addPlaceHolderInSchema(string $graphQlSchemaContent): string
     {
         $placeholderField = self::GRAPHQL_PLACEHOLDER_FIELD_NAME;
         $typesKindsPattern = '(type|interface|input|union)';
         $enumKindsPattern = '(enum)';
         $typeNamePattern = '([_A-Za-z][_0-9A-Za-z]+)';
-        $typeDefinitionPattern = '([^\{]*)(\{[\s\t\n\r^\}]*\})';
+        $typeDefinitionPattern = '([^\{\}]*)(\{[\s\t\n\r^\}]*\})';
         $spacePattern = '([\s\t\n\r]+)';
 
         //add placeholder in empty types
@@ -283,7 +402,7 @@ class GraphQlReader implements ReaderInterface
      * @param array $partialResults
      * @return array
      */
-    private function removePlaceholderFromResults(array $partialResults) : array
+    private function removePlaceholderFromResults(array $partialResults): array
     {
         $placeholderField = self::GRAPHQL_PLACEHOLDER_FIELD_NAME;
         //remove parsed placeholders
@@ -298,49 +417,4 @@ class GraphQlReader implements ReaderInterface
         }
         return $partialResults;
     }
-
-    /**
-     * Get a module name by file path
-     *
-     * @param string $file
-     * @return string
-     */
-    private static function getModuleNameForRelevantFile(string $file): string
-    {
-        if (!isset(self::$componentRegistrar)) {
-            self::$componentRegistrar = new ComponentRegistrar();
-        }
-        $foundModuleName = '';
-        foreach (self::$componentRegistrar->getPaths(ComponentRegistrar::MODULE) as $moduleName => $moduleDir) {
-            if (strpos($file, $moduleDir . '/') !== false) {
-                $foundModuleName = str_replace('_', '\\', $moduleName);
-                break;
-            }
-        }
-
-        return $foundModuleName;
-    }
-
-    /**
-     * Add a module name to types
-     *
-     * @param array $source
-     * @param string $filePath
-     * @return array
-     */
-    private function addModuleNameToTypes(array $source, string $filePath): array
-    {
-        foreach ($source as $typeName => $typeDefinition) {
-            if (!isset($typeDefinition['module'])) {
-                $hasTypeResolver = (bool)($typeDefinition['typeResolver'] ?? false);
-                $hasImplements = (bool)($typeDefinition['implements'] ?? false);
-                $typeDefinition = (bool)($typeDefinition['type'] ?? false);
-                if ((($typeDefinition === InterfaceType::GRAPHQL_INTERFACE && $hasTypeResolver) || $hasImplements)) {
-                    $source[$typeName]['module'] = self::getModuleNameForRelevantFile($filePath);
-                }
-            }
-        }
-
-        return $source;
-    }
-}
+}
\ No newline at end of file
-- 
2.20.1

