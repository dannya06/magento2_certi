From 42d1870ad6f4bacb81ff9b31b221a8e94f9b9f2c Mon Sep 17 00:00:00 2001
From: icube-yuwan <yuma.anugrah@mail.sirclo.com>
Date: Tue, 30 Aug 2022 04:46:56 +0000
Subject: [PATCH] patch

---
 .../GraphQlSchemaStitching/GraphQlReader.php  | 205 ++++++++++++------
 1 file changed, 139 insertions(+), 66 deletions(-)

diff --git a/vendor/magento/framework/GraphQlSchemaStitching/GraphQlReader.php b/vendor/magento/framework/GraphQlSchemaStitching/GraphQlReader.php
index 9ae1d857b..845bf7c64 100644
--- a/vendor/magento/framework/GraphQlSchemaStitching/GraphQlReader.php
+++ b/vendor/magento/framework/GraphQlSchemaStitching/GraphQlReader.php
@@ -9,10 +9,8 @@ namespace Magento\Framework\GraphQlSchemaStitching;
 
 use GraphQL\Type\Definition\ScalarType;
 use GraphQL\Utils\BuildSchema;
-use Magento\Framework\Component\ComponentRegistrar;
 use Magento\Framework\Config\FileResolverInterface;
 use Magento\Framework\Config\ReaderInterface;
-use Magento\Framework\GraphQl\Type\TypeManagement;
 use Magento\Framework\GraphQlSchemaStitching\GraphQlReader\TypeMetaReaderInterface as TypeReaderComposite;
 use Magento\Framework\GraphQlSchemaStitching\GraphQlReader\Reader\InterfaceType;
 
@@ -29,6 +27,8 @@ class GraphQlReader implements ReaderInterface
     public const GRAPHQL_INTERFACE = 'graphql_interface';
 
     /**
+     * File locator
+     *
      * @var FileResolverInterface
      */
     private $fileResolver;
@@ -48,11 +48,6 @@ class GraphQlReader implements ReaderInterface
      */
     private $defaultScope;
 
-    /**
-     * @var ComponentRegistrar
-     */
-    private static $componentRegistrar;
-
     /**
      * @param FileResolverInterface $fileResolver
      * @param TypeReaderComposite $typeReader
@@ -69,13 +64,11 @@ class GraphQlReader implements ReaderInterface
         $this->typeReader = $typeReader;
         $this->defaultScope = $defaultScope;
         $this->fileName = $fileName;
-        $typeManagement = new TypeManagement();
-        $typeManagement->overrideStandardGraphQLTypes();
     }
 
     /**
      * @inheritdoc
-     *
+     * @SuppressWarnings(PHPMD.CyclomaticComplexity)
      * @param string|null $scope
      * @return array
      */
@@ -84,28 +77,103 @@ class GraphQlReader implements ReaderInterface
         $results = [];
         $scope = $scope ?: $this->defaultScope;
         $schemaFiles = $this->fileResolver->get($this->fileName, $scope);
-
         if (!count($schemaFiles)) {
             return $results;
         }
 
         /**
+         * Gather as many schema together to be parsed in one go for performance
+         * Collect any duplicate types in an array to retry after the initial large parse
+         *
          * Compatible with @see GraphQlReader::parseTypes
          */
+        $typesToRedo = [];
         $knownTypes = [];
-        foreach ($schemaFiles as $filePath => $partialSchemaContent) {
-            $partialSchemaTypes = $this->parseTypes($partialSchemaContent);
+        foreach ($schemaFiles as $partialSchemaContent) {
+            $partialSchemaTypes = $this->parseTypesWithUnionHandling($partialSchemaContent);
+
+            // Filter out duplicated ones and save them into a list to be retried
+            $tmpTypes = $knownTypes;
+            foreach ($partialSchemaTypes as $intendedKey => $partialSchemaType) {
+                if (isset($tmpTypes[$intendedKey])) {
+                    if (!isset($typesToRedo[$intendedKey])) {
+                        $typesToRedo[$intendedKey] = [];
+                    }
+                    $typesToRedo[$intendedKey][] = $partialSchemaType;
+                    continue;
+                }
+                $tmpTypes[$intendedKey] = $partialSchemaType;
+            }
+            $knownTypes = $tmpTypes;
+        }
 
-            // Keep declarations from current partial schema, add missing declarations from all previously read schemas
-            $knownTypes = $partialSchemaTypes + $knownTypes;
-            $schemaContent = implode("\n", $knownTypes);
+        /**
+         * Read this large batch of data, this builds most of the $results array
+         */
+        $schemaContent = implode("\n", $knownTypes);
+        $results = $this->readPartialTypes($schemaContent);
+
+        /**
+         * Go over the list of types to be retried and batch them up into as few batches as possible
+         */
+        $typesToRedoBatches = [];
+        foreach ($typesToRedo as $type => $batches) {
+            foreach ($batches as $id => $data) {
+                if (!isset($typesToRedoBatches[$id])) {
+                    $typesToRedoBatches[$id] = [];
+                }
+                $typesToRedoBatches[$id][$type] = $data;
+            }
+        }
+
+        /**
+         * Process each remaining batch with the minimal amount of additional schema data for performance
+         */
+        foreach ($typesToRedoBatches as $typesToRedoBatch) {
+            $typesToUse =  $this->getTypesToUse($typesToRedoBatch, $knownTypes);
+            $knownTypes = $typesToUse + $knownTypes;
+            $schemaContent = implode("\n", $typesToUse);
 
             $partialResults = $this->readPartialTypes($schemaContent);
             $results = array_replace_recursive($results, $partialResults);
-            $results = $this->addModuleNameToTypes($results, $filePath);
         }
 
-        return $this->copyInterfaceFieldsToConcreteTypes($results);
+        $results = $this->copyInterfaceFieldsToConcreteTypes($results);
+        return $results;
+    }
+
+    /**
+     * Get the minimum amount of additional types so that performance is improved
+     *
+     * The use of a strpos check here is a bit odd in the context of feeding data into an AST but for the performance
+     * gains and to prevent downtime it is necessary
+     *
+     * @link https://github.com/webonyx/graphql-php/issues/244
+     * @link https://github.com/webonyx/graphql-php/issues/244#issuecomment-383912418
+     *
+     * @param array $typesToRedoBatch
+     * @param array $types
+     * @return array
+     */
+    private function getTypesToUse($typesToRedoBatch, $types): array
+    {
+        $totalKnownSymbolsCount = count($typesToRedoBatch) + count($types);
+
+        $typesToUse = $typesToRedoBatch;
+        for ($i=0; $i < $totalKnownSymbolsCount; $i++) {
+            $changesMade = false;
+            $schemaContent = implode("\n", $typesToUse);
+            foreach ($types as $type => $schema) {
+                if ((!isset($typesToUse[$type]) && strpos($schemaContent, $type) !== false)) {
+                    $typesToUse[$type] = $schema;
+                    $changesMade = true;
+                }
+            }
+            if (!$changesMade) {
+                break;
+            }
+        }
+        return $typesToUse;
     }
 
     /**
@@ -137,6 +205,56 @@ class GraphQlReader implements ReaderInterface
         return $this->removePlaceholderFromResults($partialResults);
     }
 
+    /**
+     * Extract types as string from a larger string that represents the graphql schema using regular expressions
+     *
+     * The regex in parseTypes does not have the ability to split out the union data from the type below it for example
+     *
+     *  > union X = Y | Z
+     *  >
+     *  > type foo {}
+     *
+     * This would produce only type key from parseTypes, X, which would contain also the type foo entry.
+     *
+     * This wrapper does some post processing as a workaround to split out the union data from the type data below it
+     * which would give us two entries, X and foo
+     *
+     * @param string $graphQlSchemaContent
+     * @return string[] [$typeName => $typeDeclaration, ...]
+     */
+    private function parseTypesWithUnionHandling(string $graphQlSchemaContent): array
+    {
+        $types = $this->parseTypes($graphQlSchemaContent);
+
+        /*
+         * A union schema contains also the data from the schema below it
+         *
+         * If there are two newlines in this union schema then it has data below its definition, meaning it contains
+         * type information not relevant to its actual type
+         */
+        $unionTypes = array_filter(
+            $types,
+            function ($t) {
+                return (strpos($t, 'union ') !== false) && (strpos($t, PHP_EOL . PHP_EOL) !== false);
+            }
+        );
+
+        foreach ($unionTypes as $type => $schema) {
+            $splitSchema = explode(PHP_EOL . PHP_EOL, $schema);
+            // Get the type data at the bottom, this will be the additional type data not related to the union
+            $additionalTypeSchema = end($splitSchema);
+            // Parse the additional type from the bottom so we can have its type key => schema pair
+            $additionalTypeData = $this->parseTypes($additionalTypeSchema);
+            // Fix the union type schema so it does not contain the definition below it
+            $types[$type] = str_replace($additionalTypeSchema, '', $schema);
+            // Append the additional data to types array
+            $additionalTypeKey = array_key_first($additionalTypeData);
+            $types[$additionalTypeKey] = $additionalTypeData[$additionalTypeKey];
+        }
+
+        return $types;
+    }
+
     /**
      * Extract types as string from a larger string that represents the graphql schema using regular expressions
      *
@@ -147,7 +265,7 @@ class GraphQlReader implements ReaderInterface
     {
         $typeKindsPattern = '(type|interface|union|enum|input)';
         $typeNamePattern = '([_A-Za-z][_0-9A-Za-z]+)';
-        $typeDefinitionPattern = '([^\{]*)(\{[^\}]*\})';
+        $typeDefinitionPattern = '([^\{\}]*)(\{[^\}]*\})';
         $spacePattern = '[\s\t\n\r]+';
 
         preg_match_all(
@@ -259,7 +377,7 @@ class GraphQlReader implements ReaderInterface
         $typesKindsPattern = '(type|interface|input|union)';
         $enumKindsPattern = '(enum)';
         $typeNamePattern = '([_A-Za-z][_0-9A-Za-z]+)';
-        $typeDefinitionPattern = '([^\{]*)(\{[\s\t\n\r^\}]*\})';
+        $typeDefinitionPattern = '([^\{\}]*)(\{[\s\t\n\r^\}]*\})';
         $spacePattern = '([\s\t\n\r]+)';
 
         //add placeholder in empty types
@@ -299,49 +417,4 @@ class GraphQlReader implements ReaderInterface
         }
         return $partialResults;
     }
-
-    /**
-     * Get a module name by file path
-     *
-     * @param string $file
-     * @return string
-     */
-    private static function getModuleNameForRelevantFile(string $file): string
-    {
-        if (!isset(self::$componentRegistrar)) {
-            self::$componentRegistrar = new ComponentRegistrar();
-        }
-        $foundModuleName = '';
-        foreach (self::$componentRegistrar->getPaths(ComponentRegistrar::MODULE) as $moduleName => $moduleDir) {
-            if (strpos($file, $moduleDir . '/') !== false) {
-                $foundModuleName = str_replace('_', '\\', $moduleName);
-                break;
-            }
-        }
-
-        return $foundModuleName;
-    }
-
-    /**
-     * Add a module name to types
-     *
-     * @param array $source
-     * @param string $filePath
-     * @return array
-     */
-    private function addModuleNameToTypes(array $source, string $filePath): array
-    {
-        foreach ($source as $typeName => $typeDefinition) {
-            if (!isset($typeDefinition['module'])) {
-                $hasTypeResolver = (bool)($typeDefinition['typeResolver'] ?? false);
-                $hasImplements = (bool)($typeDefinition['implements'] ?? false);
-                $typeDefinition = (bool)($typeDefinition['type'] ?? false);
-                if ((($typeDefinition === InterfaceType::GRAPHQL_INTERFACE && $hasTypeResolver) || $hasImplements)) {
-                    $source[$typeName]['module'] = self::getModuleNameForRelevantFile($filePath);
-                }
-            }
-        }
-
-        return $source;
-    }
-}
+}
\ No newline at end of file
-- 
2.30.2

